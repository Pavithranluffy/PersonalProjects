{"ast":null,"code":"var _jsxFileName = \"/Users/pavithranr/Documents/MyProjects-Git/WhatsApp-webSocket/whatsapp-websocket/src/Components/context/ConversationProvider.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { createContext, useContext, useState } from \"react\";\nimport LocalStorage from \"../Hooks/LocalStorage\";\nimport { useContact } from \"./ContactsProvider\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ConversationContext = /*#__PURE__*/createContext();\nexport function useConversation() {\n  _s();\n  return useContext(ConversationContext);\n}\n_s(useConversation, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport function ConversationProvider({\n  children,\n  id\n}) {\n  _s2();\n  const [conversation, setConverstaion] = LocalStorage('conversation', []);\n  const [selectConversationIndex, setSelectConversationIndex] = useState(0);\n  const {\n    contact\n  } = useContact();\n  function createConversation(recipients) {\n    setConverstaion(prevconversation => {\n      return [...prevconversation, {\n        recipients,\n        messages: []\n      }];\n    });\n  }\n  function addMessagetoConversation({\n    recipients,\n    text,\n    sender\n  }) {\n    setConverstaion(prevconversation => {\n      let madeChange = false;\n      const newmessage = {\n        sender,\n        text\n      };\n      const newConversation = prevconversation.map(conversation => {\n        if (ArrayEquality(conversation.recipients, recipients)) {\n          madeChange = true;\n          return {\n            ...conversation,\n            messages: [...conversation.messages, newmessage]\n          };\n        }\n        return conversation;\n      });\n      if (madeChange) {\n        return newConversation;\n      } else {\n        return [...prevconversation, {\n          recipients: recipients,\n          messages: [newmessage]\n        }];\n      }\n    });\n  }\n  function sendmessage({\n    recipients,\n    text\n  }) {\n    addMessagetoConversation({\n      recipients,\n      text,\n      sender: id\n    });\n  }\n\n  //Now we can format our conversation into easy manner \n  //As we know conversation has stored the group of recipeints ids \n  //First wee need to iterate the conversatinon and inside we need to iterate the recipuents and after we need to find the matching\n  //recipient id with contacts information we have \n\n  const formattedConversations = conversation.map((conversation, index) => {\n    // For each conversation, process its recipients\n    const recipients = conversation.recipients.map(recipientId => {\n      // Find the contact that matches this recipient ID\n      const foundContact = contact.find(contact => contact.id === recipientId);\n\n      // If contact found, use its name, otherwise use the ID as fallback\n      return {\n        id: recipientId,\n        name: foundContact ? foundContact.name : recipientId\n      };\n    });\n\n    //And also See this Current Conversation is selected \n    const selected = index === selectConversationIndex;\n\n    // Return a new conversation object with formatted recipients\n    return {\n      ...conversation,\n      // Keep existing conversation properties\n      recipients,\n      // Add formatted recipients array\n      selected //If this Conversation is selected\n    };\n  });\n  const value = {\n    conversation: formattedConversations,\n    currentConversation: formattedConversations[selectConversationIndex],\n    //To Track the current conversatoin we are doing this \n    sendmessage,\n    selectConversationIndex: setSelectConversationIndex,\n    createConversation\n  };\n  return /*#__PURE__*/_jsxDEV(ConversationContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 90,\n    columnNumber: 9\n  }, this);\n}\n_s2(ConversationProvider, \"n1Hi0v5gKG8aS54f1s7KxN9l20A=\", false, function () {\n  return [useContact];\n});\n_c = ConversationProvider;\nfunction ArrayEquality(a, b) {\n  if ((a === null || a === void 0 ? void 0 : a.length) !== (b === null || b === void 0 ? void 0 : b.length)) return true;\n  a.sort();\n  b.sort();\n  return a.every((element, index) => {\n    return element === b[index];\n  });\n}\n_c2 = ArrayEquality;\nvar _c, _c2;\n$RefreshReg$(_c, \"ConversationProvider\");\n$RefreshReg$(_c2, \"ArrayEquality\");","map":{"version":3,"names":["createContext","useContext","useState","LocalStorage","useContact","jsxDEV","_jsxDEV","ConversationContext","useConversation","_s","ConversationProvider","children","id","_s2","conversation","setConverstaion","selectConversationIndex","setSelectConversationIndex","contact","createConversation","recipients","prevconversation","messages","addMessagetoConversation","text","sender","madeChange","newmessage","newConversation","map","ArrayEquality","sendmessage","formattedConversations","index","recipientId","foundContact","find","name","selected","value","currentConversation","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","a","b","length","sort","every","element","_c2","$RefreshReg$"],"sources":["/Users/pavithranr/Documents/MyProjects-Git/WhatsApp-webSocket/whatsapp-websocket/src/Components/context/ConversationProvider.js"],"sourcesContent":["import { createContext, useContext, useState } from \"react\";\nimport LocalStorage from \"../Hooks/LocalStorage\";\nimport { useContact } from \"./ContactsProvider\";\n\n\n\nexport const ConversationContext = createContext();\n\n\nexport function useConversation(){\n    return useContext(ConversationContext);\n}\n\nexport function ConversationProvider({children,id}){\n    const [conversation,setConverstaion] = LocalStorage('conversation',[]);\n    const [selectConversationIndex,setSelectConversationIndex] = useState(0);\n    const {contact} = useContact();\n    function createConversation(recipients){\n        setConverstaion(prevconversation=>{\n            return[...prevconversation,{recipients,messages : []}]\n        })\n        \n    }\n    function addMessagetoConversation({recipients,text,sender}){\n        setConverstaion(prevconversation => {\n            let madeChange = false;\n            const newmessage = {sender,text};\n            const newConversation = prevconversation.map(conversation=>{\n                if(ArrayEquality(conversation.recipients,recipients)){\n                    madeChange = true;\n                    return {\n                        ...conversation,\n                        messages:[...conversation.messages,newmessage]\n                    }\n                }\n                return conversation;\n            })\n            if(madeChange){\n                return newConversation\n            }\n            else{\n                return[\n                    ...prevconversation,\n                    {recipients:recipients,messages:[newmessage]}\n                ]\n            }\n        })\n\n    }\n     function sendmessage({recipients,text}){\n        addMessagetoConversation({recipients,text,sender : id })\n    }\n\n    //Now we can format our conversation into easy manner \n    //As we know conversation has stored the group of recipeints ids \n    //First wee need to iterate the conversatinon and inside we need to iterate the recipuents and after we need to find the matching\n    //recipient id with contacts information we have \n    \n    const formattedConversations = conversation.map((conversation,index) => {\n        // For each conversation, process its recipients\n        const recipients = conversation.recipients.map(recipientId => {\n            // Find the contact that matches this recipient ID\n            const foundContact = contact.find(contact => contact.id === recipientId);\n            \n            // If contact found, use its name, otherwise use the ID as fallback\n            return {\n                id: recipientId,\n                name: foundContact ? foundContact.name : recipientId\n            };\n        });\n\n        //And also See this Current Conversation is selected \n        const selected  = index === selectConversationIndex;\n    \n        // Return a new conversation object with formatted recipients\n        return {\n            ...conversation, // Keep existing conversation properties\n            recipients, // Add formatted recipients array\n            selected //If this Conversation is selected\n        };\n    });\n    const value = {\n        conversation : formattedConversations,\n        currentConversation:formattedConversations[selectConversationIndex],//To Track the current conversatoin we are doing this \n        sendmessage,\n        selectConversationIndex : setSelectConversationIndex,\n        createConversation\n    }\n    return(\n        <ConversationContext.Provider value={value}>\n        {children}\n        </ConversationContext.Provider>\n    )\n}\n\n\nfunction ArrayEquality(a,b){\n    if (a?.length !== b?.length) return true;\n    a.sort();\n    b.sort()\n\n    return a.every((element,index)=>{\n        return element === b[index];\n    })\n\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}